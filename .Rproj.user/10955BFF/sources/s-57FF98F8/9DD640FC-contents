

#change this one!

InteRD2<-function (bulk.data,list_marker,cell_type_unique,comb_sampled,ave_est,ave_sd,lambda_option1){
  # bulk.eset<-pseudo.seger
  # bulk_data<-(exprs(bulk.eset))
  # marker_gene_used<-unlist(list_marker)
  # gene_test<-setdiff(rownames(bulk_data),marker_gene_used)
  # bulk_data<-bulk_data[gene_test,]
  # exprs_data<-as.matrix(bulk_data)
  # pdata<-data.frame(sample=colnames(bulk_data))
  # fdata<-data.frame(genes=rownames(bulk_data))
  # rownames(pdata)<-colnames(bulk_data)
  # rownames(fdata)<-rownames(bulk_data)
  # pseudo.seger_test<-ExpressionSet(exprs_data,
  #                                  AnnotatedDataFrame(pdata),
  #                                  AnnotatedDataFrame(fdata))
  bulk.data_test<-testset(eset=bulk.data,list.marker=list_marker)
  
  #run reference free approach
  comb_sampled<-comb_sampled[,cell_type_unique]
  ct.sub<-cell_type_unique
  bulk.eset<-bulk.data
  bulk_matrix_raw<-(exprs(bulk.eset))
  find_zero_index<-which(rowSums(bulk_matrix_raw,na.rm=T)*1e5==0)
  if(length(find_zero_index)>0)
  {
    bulk_nozero<-getCPM0(bulk_matrix_raw[-find_zero_index,])
  }else{
    bulk_nozero<-getCPM0(bulk_matrix_raw)
  }
  marker_genes<-unlist(list_marker) #match the marker gene 
  #check marker gene availability for each cell types
  marker_list_sub_i<-lapply(1:length(list_marker),function (xx)
  {
    marker_xx<-intersect(list_marker[[xx]],rownames(bulk_nozero)) #create new marker list
  }
  )
  names(marker_list_sub_i)<-ct.sub
  gene_used<-unlist(marker_list_sub_i) #vectorize the values
  cluster_identifier<-unlist(lapply(1:length(marker_list_sub_i),function (xx)
  {
    rep(xx,length(marker_list_sub_i[[xx]])) #create the identifier to discriminate which cell type are markers coming from
  }
  ))
  #setdiff(unlist(list_marker),intersect(rownames(bulk_nozero),unlist(list_marker)))
  marker_all<-unlist(list_marker)
  #lambda_option<-c(seq(from=0,to=0.075,length=15),1,10,30,50,1000)
  #lambda_option<-c(1)
  group<-bulk.data@phenoData@data[["groups"]]
  criterion<-NULL
  est_all<-rep()
  for(lambda1 in lambda_option1)
  {
    iter<-0
    prop_old<-matrix(1/length(ct.sub),nrow=ncol(bulk_matrix_raw),ncol=length(ct.sub))
    X<-t(sapply(1:length(gene_used),function (xx)
    {
      x_xx<-rep(0,length(ct.sub))
      gene_xx<-gene_used[xx]
      bulk_xx<-bulk_nozero[gene_xx,]
      cell_type_index<-cluster_identifier[xx]
      prop_xx<-prop_old[,cell_type_index]
      #x_xx[cell_type_index]<-sum((bulk_xx*prop_xx))/sum(prop_xx^2)*1e5
      x_xx[cell_type_index]<-sum(bulk_xx)/sum(prop_xx)*1e5 #this formula is weird, I think the previous one is better
      x_xx
    }
    ))
    rownames(X)<-gene_used
    lambda_adjust<-mean((bulk_nozero[gene_used,]*1e5-X%*%t(prop_old))^2)
    repeat{
      X<-t(sapply(1:length(gene_used),function (xx)
      {
        x_xx<-rep(0,length(ct.sub))
        gene_xx<-gene_used[xx]
        bulk_xx<-bulk_nozero[gene_xx,]
        cell_type_index<-cluster_identifier[xx]
        prop_xx<-prop_old[,cell_type_index]
        #x_xx[cell_type_index]<-sum((bulk_xx*prop_xx))/sum(prop_xx^2)*1e5
        x_xx[cell_type_index]<-sum(bulk_xx)/sum(prop_xx)*1e5 #this formula is weird, I think the previous one is better
        x_xx
      }
      ))
      rownames(X)<-gene_used
      
      prop_new<-t(sapply(1:ncol(bulk_nozero), function (x)
      {
        #each subject estimation
        Y_initial<-bulk_nozero[,x]
        zero_index<-which(Y_initial==0) #find genes with zero expression in current subject
        if (length(zero_index)>0)
        {
          Y_initial<-Y_initial[-zero_index] #delate zero expressed genes !!!!!!!!!!!!check this!!!!!!!!!!!
        }
        #Y_initial<-Y_initial[Y_initial<quantile(Y_initial,0.99)] #remove the outliers
        gene_names<-names(Y_initial)
        marker_genes<-intersect(gene_names,marker_all) #match the marker gene
        #check marker gene availability for each cell types
        marker_list_sub_i<-lapply(1:length(list_marker),function (xx)
        {
          marker_xx<-intersect(list_marker[[xx]],marker_genes) #create new marker list
        }
        )
        names(marker_list_sub_i)<-ct.sub
        gene_used<-unlist(marker_list_sub_i) #vectorize the values
        cluster_identifier<-unlist(lapply(1:length(marker_list_sub_i),function (xx)
        {
          rep(xx,length(marker_list_sub_i[[xx]])) #create the identifier to discriminate which cell type are markers coming from
        }
        ))
        find_zero_counts<-which(table(cluster_identifier)==0)
        
        #construct Y and corresponding augmented iterms (major change)
        Y<-Y_initial[gene_used]*1e5
        lambda_adjust1<-lambda_adjust*lambda1
        
        ave_truep<-as.matrix(comb_sampled)[x,]*sqrt(lambda_adjust1)
        ave_truep2<-ave_est*sqrt(lambda_adjust)/ave_sd
        
        X<-X[gene_used,]
        X_aug<-sqrt(lambda_adjust1)*diag(1,length(ct.sub))
        X_aug2<-sqrt(lambda_adjust)*diag(1,length(ct.sub))/ave_sd
        
        Y_aug<-ave_truep
        y_aug2<-ave_truep2
        #Y_aug<-c(sapply(1:length(combo), function (xx) {sqrt(lambda_adjust*weight[xx])*(combo[[xx]][x,])}))
        Y_comb<-c(Y,Y_aug,y_aug2)
        
        #X_aug<-do.call(rbind,lapply(1:length(combo), function (xx) {sqrt(lambda_adjust*weight[xx])*diag(1,length(ct.sub))}))
        X_comb<-rbind(X,X_aug,X_aug2)
        #heatmap(X)
        ##construct the constrain matrix
        E_used<-rep(1,length(ct.sub))
        F_used<-1
        G_used<-diag(1,length(ct.sub))
        H_used<-rep(0,length(ct.sub))
        #fit<-lsei(A=X,B=Y,E=E_used,F=F_used,G=G_used,H=H_used)
        #fit$X
        fit<-nnls(A=X_comb,B=Y_comb)
        
        #calcualte GCV values
        #x_x<-t(X)%*%X
        #inverse_term<-solve(x_x+sum(lambda_adjust*weight))
        #P_lambda<-X%*%inverse_term%*%t(X)
        #penalty_1<-(1-(tr(P_lambda)-1)/length(Y))^2
        #penalty_2<-
        #gcv_values<-(Y%*%((diag(1,nrow(P_lambda))-P_lambda)^2)%*%Y)/penalty_1+
        fit$X/sum(fit$X)
        #print(x)
      })
      )
      if(mean(abs(prop_new[,1:length(ct.sub)]-prop_old))<0.0005 | iter>1000)
      {
        break
      }else{
        prop_old<-prop_new[,1:length(ct.sub)]
        lambda_adjust<-mean((bulk_nozero[gene_used,]*1e5-X%*%t(prop_old))^2)
        iter<-iter+1
      }
    }
    est_meta_all<-list(prop_new)
    criterion_sub<-criteria_onegroup(bulk_data=bulk.data_test, prop_used=prop_new)[2]
    criterion<-c(criterion,criterion_sub)
    est_all<-append(est_all,est_meta_all)
    #print(ll)
  }
  
  prop_est<-est_all[[which.min(criterion)]]
  list(est=est_all,metrics=criterion)
}


RF<-function (bulk.data,list_marker,cell_type_unique){
  # bulk.eset<-pseudo.seger
  # bulk_data<-(exprs(bulk.eset))
  # marker_gene_used<-unlist(list_marker)
  # gene_test<-setdiff(rownames(bulk_data),marker_gene_used)
  # bulk_data<-bulk_data[gene_test,]
  # exprs_data<-as.matrix(bulk_data)
  # pdata<-data.frame(sample=colnames(bulk_data))
  # fdata<-data.frame(genes=rownames(bulk_data))
  # rownames(pdata)<-colnames(bulk_data)
  # rownames(fdata)<-rownames(bulk_data)
  # pseudo.seger_test<-ExpressionSet(exprs_data,
  #                                  AnnotatedDataFrame(pdata),
  #                                  AnnotatedDataFrame(fdata))
  bulk.data_test<-testset(eset=bulk.data,list.marker=list_marker)
  
  #run reference free approach
  ct.sub<-cell_type_unique
  bulk.eset<-bulk.data
  bulk_matrix_raw<-(exprs(bulk.eset))
  find_zero_index<-which(rowSums(bulk_matrix_raw,na.rm=T)*1e5==0)
  if(length(find_zero_index)>0)
  {
    bulk_nozero<-getCPM0(bulk_matrix_raw[-find_zero_index,])
  }else{
    bulk_nozero<-getCPM0(bulk_matrix_raw)
  }
  marker_all<-unlist(list_marker)
  #lambda_option<-c(seq(from=0,to=0.075,length=15),1,10,30,50,1000)
  #lambda_option<-c(1)
  group<-bulk.data@phenoData@data[["groups"]]
  criterion<-NULL
  est_all<-list(NULL)
  lambda_option<-0
  
  for(ll in 1:length(lambda_option))
  {
    iter<-0
    prop_old<-matrix(1/length(ct.sub),nrow=ncol(bulk_matrix_raw),ncol=length(ct.sub))
    lambda<-lambda_option[ll]
    repeat{
      prop_new<-t(sapply(1:ncol(bulk_nozero), function (x)
      {
        #each subject estimation
        Y_initial<-bulk_nozero[,x]
        zero_index<-which(Y_initial==0) #find genes with zero expression in current subject
        if (length(zero_index)>0)
        {
          Y_initial<-Y_initial[-zero_index] #delate zero expressed genes !!!!!!!!!!!!check this!!!!!!!!!!!
        }
        #Y_initial<-Y_initial[Y_initial<quantile(Y_initial,0.99)] #remove the outliers
        gene_names<-names(Y_initial)
        marker_genes<-intersect(gene_names,marker_all) #match the marker gene
        #check marker gene availability for each cell types
        marker_list_sub_i<-lapply(1:length(list_marker),function (xx)
        {
          marker_xx<-intersect(list_marker[[xx]],marker_genes) #create new marker list
        }
        )
        names(marker_list_sub_i)<-ct.sub
        gene_used<-unlist(marker_list_sub_i) #vectorize the values
        cluster_identifier<-unlist(lapply(1:length(marker_list_sub_i),function (xx)
        {
          rep(xx,length(marker_list_sub_i[[xx]])) #create the identifier to discriminate which cell type are markers coming from
        }
        ))
        find_zero_counts<-which(table(cluster_identifier)==0)
        
        #construct Y
        Y<-Y_initial[gene_used]*1e5
        lambda_adjust<-sum(max(Y)^2)*lambda
        # if(ll>=length(lambda_option)-4)
        # {
        #   ave_truep<-as.matrix(comb_sampled)[x,]
        # }else{
        #   ave_truep<-ave_est
        # }
        
        Y_aug<-c(1:length(ct.sub))*sqrt(lambda_adjust)
        #Y_aug<-ave_truep*sqrt(lambda_adjust)/ave_sd
        #Y_aug<-c(sapply(1:length(combo), function (xx) {sqrt(lambda_adjust*weight[xx])*(combo[[xx]][x,])}))
        Y_comb<-c(Y,Y_aug)
        
        #construct X matrix
        X<-t(sapply(1:length(gene_used),function (xx)
        {
          x_xx<-rep(0,length(ct.sub))
          gene_xx<-gene_used[xx]
          bulk_xx<-bulk_nozero[gene_xx,]
          cell_type_index<-cluster_identifier[xx]
          prop_xx<-prop_old[,cell_type_index]
          #x_xx[cell_type_index]<-sum((bulk_xx*prop_xx))/sum(prop_xx^2)*1e5
          x_xx[cell_type_index]<-sum(bulk_xx)/sum(prop_xx)*1e5 #this formula is weird, I think the previous one is better
          x_xx
        }
        ))
        
        X_aug<-sqrt(lambda_adjust)*diag(1,length(ct.sub))
        
        #X_aug<-do.call(rbind,lapply(1:length(combo), function (xx) {sqrt(lambda_adjust*weight[xx])*diag(1,length(ct.sub))}))
        X_comb<-rbind(X,X_aug)
        #heatmap(X)
        ##construct the constrain matrix
        E_used<-rep(1,length(ct.sub))
        F_used<-1
        G_used<-diag(1,length(ct.sub))
        H_used<-rep(0,length(ct.sub))
        #fit<-lsei(A=X,B=Y,E=E_used,F=F_used,G=G_used,H=H_used)
        #fit$X
        fit<-nnls(A=X_comb,B=Y_comb)
        
        #calcualte GCV values
        #x_x<-t(X)%*%X
        #inverse_term<-solve(x_x+sum(lambda_adjust*weight))
        #P_lambda<-X%*%inverse_term%*%t(X)
        #penalty_1<-(1-(tr(P_lambda)-1)/length(Y))^2
        #penalty_2<-
        #gcv_values<-(Y%*%((diag(1,nrow(P_lambda))-P_lambda)^2)%*%Y)/penalty_1+
        fit$X/sum(fit$X)
        #print(x)
      })
      )
      if(mean(abs(prop_new[,1:length(ct.sub)]-prop_old))<0.001 | iter>1000)
      {
        break
      }else{
        prop_old<-prop_new[,1:length(ct.sub)]
        iter<-iter+1
      }
    }
    est_meta_all<-prop_new
    criterion_sub<-criteria_onegroup(bulk_data=bulk.data_test, prop_used=prop_new)[2]
    criterion<-c(criterion,criterion_sub)
    est_all[[ll]]<-est_meta_all
    print(ll)
  }
  
  prop_est<-est_all[[which.min(criterion)]]
  list(est=est_all,metrics=criterion)
}
