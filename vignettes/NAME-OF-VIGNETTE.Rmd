---
title: "InteRD"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{InteRD}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Installation
```{r,eval=FALSE}
if (!require("devtools")) {
  install.packages("devtools")
}
devtools::install_github("chencxxy28/InteRD")
```

In this tutorial, we use SCDC ([Dong et al. (2021)](https://academic.oup.com/bib/article/22/1/416/5699815)) for illustration to conduct reference-based deconvolution. 

```{r}
#load
library(InteRD)
```

## Simulation Studies
First, read in scRNA-seq data from our website 
```{r}
readRDSFromWeb <- function(ref) {
  readRDS(gzcon(url(ref)))
}
seger <- readRDSFromWeb("https://github.com/chencxxy28/MultiRD/raw/master/vignettes/data/segerstolpe.rds")
baron <- readRDSFromWeb("https://github.com/chencxxy28/MultiRD/raw/master/vignettes/data/baron.rds")
xin<-readRDSFromWeb("https://github.com/chencxxy28/MultiRD/raw/master/vignettes/data/Xin_nonD.rds")
```

Second, use function `generateBulk()` to create the _pseudo bulk_ samples, where `ct.varname` specifies the name of cell type clustering result variable. `sample` specifies the name of subjects information variable. `ct.sub` specifies the names of cell types used to construct _pseudo bulk_ samples. Here we provide an example where the _pseudo bulk_ samples are generated from [Segerstolpe et al. (2016)](https://www.sciencedirect.com/science/article/pii/S1550413116304363?via%3Dihub).

```{r, message=FALSE}
set.seed(1234567)
pseudo.seger<-generateBulk(seger[["sc.eset.qc"]], ct.varname = "cluster", sample = "sample", ct.sub = c("alpha","beta","delta","gamma"), nbulk = 40, low_s = 0.3, upp_s = 0.7)
truep<-pseudo.seger$true_p[complete.cases(pseudo.seger$true_p),]
```

The generated _pseudo bulk_ object contains a matrix of true cell type proportions (`pseudo.seger$truep`) and the `ExpressionSet` object (`pseudo.seger$pseudo_eset`).

InteRD1 algorithm is the first step of InteRD to do multiple reference ensemble, which takes as input the target bulk data, a list of marker genes, a list of subject-level cell type proportions based on each reference set. For illustration, we use the function `SCDC_prop()` from SCDC package ([Dong et al. (2021)](https://academic.oup.com/bib/article/22/1/416/5699815)). We regard the estimated cell type proportions from [Segerstolpe et al. (2016)](https://www.sciencedirect.com/science/article/pii/S1550413116304363?via%3Dihub) as the correct subject-level cell type information (`c_refbase_est`) and the estimated ones with subject-label shuffle from [Xin et al. (2016)](https://www.sciencedirect.com/science/article/pii/S155041311630434X?via%3Dihub) as the incorrect information (`w_refbase_est`). 

```{r, message=FALSE,results='hide'}
set.seed(1234567)
##ensemble of multiple reference sets 
#resuts based on SCDC
  pancreas.sc <- list(baron = baron$sc.eset.qc,
                      xin   = xin
  )
  SCDC_results<-SCDC_ENSEMBLE(bulk.eset = pseudo.seger$pseudo_eset, sc.eset.list = pancreas.sc, ct.varname = "cluster",
                                sample = "sample", weight.basis = T,truep = truep, ct.sub =  c("alpha","beta","delta","gamma"), search.length = 0.02,grid.search=T)
  comb<-SCDC_results$prop.only
  weight_matrix<-SCDC_results$w_table["mAD_Y",1:2]
  SCDC_ENSEMBLE_MAD<-SCDC:::wt_prop(weight_matrix,comb)

#results based on InteRD1
  list_marker<-readRDS("/Users/chixiang.chen/OneDrive - University of Maryland School of Medicine/postdoc/postdoc/deconvolution/ref_based_rd/simulations/simulation_08252021/interb1/list_markerbaron20.rds") #get markers selected from xin et al (2016)
  lambda_option<-c(0,0.01,0.05,0.1,1,5,100)
  cell_type_unique<-c("alpha","beta","delta","gamma")
  InteRD1.output<-InteRD1(bulk.data =pseudo.seger$pseudo_eset,list_marker,cell_type_unique,comb_used=comb,lambda_option)
  InteRD1<-InteRD.predict.prop(InteRD.output=InteRD1.output)
```

We provide the function `evaluate` to assess the performance of estimated proportions versus the true proportions based on mean absolute deviance (MAD, the smaller the better), concordance correlation coefficient (CCC, the larger the better), and Pearson correlation coefficient (Pearson, the larger the better).

```{r, message=FALSE}
evaluate(SCDC_ENSEMBLE_MAD,pseudo.seger$true_p)$all.eva
evaluate(InteRD1,pseudo.seger$true_p)$all.eva
```

InteRD1 algorithm is the second step of InteRD to further integrate prior biological information into the deconvolution in a robust manner. The prior information is the population-level mean cell-type proportions and their corresponding standard deviations across samples. In this tutorial, we obtain this information from scRNA-seq data from [Segerstolpe et al. (2016)](https://www.sciencedirect.com/science/article/pii/S1550413116304363?via%3Dihub).
```{r, message=FALSE}
ave_est = pop.ct.prop.scRNA(scRNA=seger[["sc.eset.qc"]],cell_type_unique=cell_type_unique)$pop.ct.prop
ave_sd = pop.ct.prop.scRNA(scRNA=seger[["sc.eset.qc"]],cell_type_unique=cell_type_unique)$pop.ct.sd
lambda_option<-c(0,seq(from=1,to=20,length=4),seq(from=30,to=100,length=4),200,500,1000000^2)
InteRD2.output<-InteRD2(bulk.data=pseudo.seger$pseudo_eset,list_marker,cell_type_unique,comb_sampled=InteRD1,ave_est,ave_sd,lambda_option=lambda_option)
InteRD2<-InteRD.predict.prop(InteRD.output=InteRD2.output)
```


Based on the evaluations, we can tell that InteRD2 is better than InteRD1, the InteRD estimates are all better than the existing method.
```{r, message=FALSE}
evaluate(SCDC_ENSEMBLE_MAD,pseudo.seger$true_p)$all.eva
evaluate(InteRD1,pseudo.seger$true_p)$all.eva
evaluate(InteRD2,pseudo.seger$true_p)$all.eva
```
